# Description

# Solution
一开始做的时候想得很复杂，分为以下三步：
1. 一直找到最左边的节点，然后k-1
2. 回溯，k-1
3. 若无法回溯，则转移到右节点

然后就卡在回溯那里不知道怎么处理了。

答案说根据BST的特点，直接用中序遍历就是一个sort array，然后取第k个。这么简单的方法我之前怎么没想到？

但是看了第二个答案，我知道了可以用stack进行回溯，就是我一开始的idea.

但实现之后发现之前想的也不对。应该要抓住BST的核心：左/右节点都比父节点小/大。比如说某一左子树有N个点，如果N>k, 
那么前k小必定在这个左子树里面。

所以可以用stack来回溯，先一直把左节点压进去，然后弹出来，k--. 在其父节点被读取前，先把其右节点压进去，因为其右节点
必然小于其父节点（注意这里有三个节点了）：先处理完其父节点的左节点，再去处理父节点，最后是其父节点的右节点。

这其实也是iterative地做中序